<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Weekly Calendar Scheduler</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #todayButton {
      margin: 10px;
      padding: 8px 16px;
      font-size: 16px;
      align-self: flex-start;
      cursor: pointer;
    }
    .calendar {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .calendar-header {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      background: #f0f0f0;
      border-bottom: 1px solid #ccc;
    }
    .calendar-header div {
      padding: 10px;
      text-align: center;
      border-right: 1px solid #ccc;
      font-weight: bold;
    }
    .calendar-header div:last-child {
      border-right: none;
    }
    .calendar-body {
      flex: 1;
      position: relative;
      overflow-y: auto;
      background: #fff;
    }
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(16, 1fr);
      position: relative;
      width: 100%;
      height: 1600px; /* 16 slots * 100px each */
    }
    .calendar-cell {
      border: 1px solid #eee;
      position: relative;
    }
    .calendar-cell.highlight {
      background-color: rgba(0, 123, 255, 0.2);
    }
    .time-label {
      position: absolute;
      left: -60px;
      width: 50px;
      text-align: right;
      font-size: 12px;
      color: #666;
    }
    .events-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* so mouse events go through */
    }
    .event {
      position: absolute;
      background-color: #007bff;
      color: #fff;
      border-radius: 4px;
      padding: 2px 4px;
      font-size: 12px;
      overflow: hidden;
      cursor: pointer;
      pointer-events: auto; /* re-enable events */
    }
    .event .resize-handle {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 6px;
      cursor: ns-resize;
      background: rgba(0,0,0,0.2);
    }
    .current-time-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: red;
      z-index: 100;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <button id="todayButton">Today</button>
  <div class="calendar">
    <div class="calendar-header">
      <div data-day="0">Monday</div>
      <div data-day="1">Tuesday</div>
      <div data-day="2">Wednesday</div>
      <div data-day="3">Thursday</div>
      <div data-day="4">Friday</div>
    </div>
    <div class="calendar-body" id="calendarBody">
      <div class="calendar-grid" id="calendarGrid">
        <!-- Cells will be generated by JS -->
      </div>
      <div class="events-container" id="eventsContainer"></div>
      <div class="current-time-line" id="currentTimeLine" style="display:none;"></div>
    </div>
  </div>
  <script>
    // Global variables and settings
    const startHour = 9;
    const endHour = 17;
    const slotDuration = 30; // minutes
    const totalSlots = ((endHour - startHour) * 60) / slotDuration; // 16
    const daysCount = 5;
    const calendarGrid = document.getElementById("calendarGrid");
    const eventsContainer = document.getElementById("eventsContainer");
    const calendarBody = document.getElementById("calendarBody");
    const currentTimeLine = document.getElementById("currentTimeLine");
    const todayButton = document.getElementById("todayButton");
    let events = []; // store events objects: {id, day, start, end, element}

    // Variables for event creation dragging
    let isCreating = false;
    let createDay = null;
    let createStartSlot = null;
    let createEndSlot = null;
    
    // Variables for resizing events
    let isResizing = false;
    let resizeEvent = null;
    let resizeStartY = 0;
    let originalEnd = 0;
    
    // Create calendar cells
    function generateCells() {
      calendarGrid.innerHTML = "";
      for (let slot = 0; slot < totalSlots; slot++) {
        for (let day = 0; day < daysCount; day++) {
          const cell = document.createElement("div");
          cell.classList.add("calendar-cell");
          cell.dataset.day = day;
          cell.dataset.slot = slot;
          calendarGrid.appendChild(cell);
        }
      }
    }
    generateCells();

    // Utility to convert slot index to time string
    function slotToTime(slotIndex) {
      const totalMinutes = startHour * 60 + slotIndex * slotDuration;
      let hour = Math.floor(totalMinutes / 60);
      let minute = totalMinutes % 60;
      const ampm = hour >= 12 ? "PM" : "AM";
      hour = hour % 12 || 12;
      return hour + ":" + (minute === 0 ? "00" : minute) + " " + ampm;
    }
    
    // Check overlapping events for a specified day
    function hasOverlap(day, newStart, newEnd, excludeId = null) {
      return events.some(ev => {
        if (ev.day !== day) return false;
        if (excludeId && ev.id === excludeId) return false;
        return !(newEnd <= ev.start || newStart >= ev.end);
      });
    }
    
    // Create an event element
    function createEventElement(day, startSlot, endSlot, title) {
      const eventDiv = document.createElement("div");
      eventDiv.classList.add("event");
      const id = Date.now() + Math.random();
      eventDiv.dataset.eventId = id;
      // calculate time in minutes from startHour
      const startTime = startHour * 60 + startSlot * slotDuration;
      const endTime = startHour * 60 + endSlot * slotDuration;
      eventDiv.innerHTML = "<div class='event-title'>" + title + "<br>" + slotToTime(startSlot) + " - " + slotToTime(endSlot) + "</div>";
      // Add resize handle
      const handle = document.createElement("div");
      handle.classList.add("resize-handle");
      eventDiv.appendChild(handle);

      // Positioning: get calendar grid dimensions
      const gridRect = calendarGrid.getBoundingClientRect();
      const cellHeight = gridRect.height / totalSlots;
      const cellWidth = gridRect.width / daysCount;
      eventDiv.style.left = (day * cellWidth) + "px";
      eventDiv.style.top = ((startSlot) * cellHeight) + "px";
      eventDiv.style.width = (cellWidth - 4) + "px"; // subtract some margin
      eventDiv.style.height = ((endSlot - startSlot) * cellHeight - 4) + "px";
      
      // Add event deletion on click (unless clicking on resize handle)
      eventDiv.addEventListener("click", function(e) {
        if(e.target.classList.contains("resize-handle")) return;
        if (confirm("Delete this event?")) {
          eventsContainer.removeChild(eventDiv);
          events = events.filter(ev => ev.id != id);
        }
        e.stopPropagation();
      });
      
      // Handle resizing
      handle.addEventListener("mousedown", function(e) {
        isResizing = true;
        resizeEvent = { id, day, startSlot, endSlot, element: eventDiv };
        resizeStartY = e.clientY;
        originalEnd = endSlot;
        e.stopPropagation();
        e.preventDefault();
      });
      
      events.push({id, day, start: startSlot, end: endSlot, element: eventDiv});
      eventsContainer.appendChild(eventDiv);
    }
    
    // Update highlighting on grid cells during selection
    function updateHighlights() {
      const cells = document.querySelectorAll(".calendar-cell");
      cells.forEach(cell => {
        const cellDay = parseInt(cell.dataset.day);
        const cellSlot = parseInt(cell.dataset.slot);
        if (cellDay === createDay && cellSlot >= Math.min(createStartSlot, createEndSlot) && cellSlot <= Math.max(createStartSlot, createEndSlot)) {
          cell.classList.add("highlight");
        } else {
          cell.classList.remove("highlight");
        }
      });
    }
    
    // Clear all highlights
    function clearHighlights() {
      const cells = document.querySelectorAll(".calendar-cell");
      cells.forEach(cell => cell.classList.remove("highlight"));
    }
    
    // Mouse event handlers for event creation
    calendarGrid.addEventListener("mousedown", function(e) {
      if (e.target.classList.contains("calendar-cell")) {
        isCreating = true;
        createDay = parseInt(e.target.dataset.day);
        createStartSlot = parseInt(e.target.dataset.slot);
        createEndSlot = createStartSlot;
        updateHighlights();
      }
    });
    
    document.addEventListener("mousemove", function(e) {
      if (isCreating) {
        // Determine which cell is under the pointer within calendarGrid
        const elem = document.elementFromPoint(e.clientX, e.clientY);
        if (elem && elem.classList.contains("calendar-cell") && parseInt(elem.dataset.day) === createDay) {
          createEndSlot = parseInt(elem.dataset.slot);
          updateHighlights();
        }
      } else if(isResizing && resizeEvent) {
        const gridRect = calendarGrid.getBoundingClientRect();
        const cellHeight = gridRect.height / totalSlots;
        const deltaY = e.clientY - resizeStartY;
        let deltaSlots = Math.round(deltaY / cellHeight);
        let newEndSlot = originalEnd + deltaSlots;
        // Constrain between start+1 and totalSlots
        newEndSlot = Math.max(resizeEvent.startSlot + 1, Math.min(newEndSlot, totalSlots));
        // Check overlap before updating visually
        if (hasOverlap(resizeEvent.day, resizeEvent.startSlot, newEndSlot, resizeEvent.id)) {
          // You can give visual feedback if needed (skipped)
        }
        // Update resizeEvent's element
        const newHeight = (newEndSlot - resizeEvent.startSlot) * cellHeight - 4;
        resizeEvent.element.style.height = newHeight + "px";
        // Update text label inside event
        const titleElem = resizeEvent.element.querySelector(".event-title");
        if(titleElem){
          titleElem.innerHTML = titleElem.textContent.split("\n")[0] + "<br>" + slotToTime(resizeEvent.startSlot) + " - " + slotToTime(newEndSlot);
        }
        // Also update the event in our array if no overlap (we check on release)
      }
    });
    
    document.addEventListener("mouseup", function(e) {
      if (isCreating) {
        clearHighlights();
        let startSlot = Math.min(createStartSlot, createEndSlot);
        let endSlot = Math.max(createStartSlot, createEndSlot) + 1; // end is exclusive, so add one slot
        // Check for overlap
        if (hasOverlap(createDay, startSlot, endSlot)) {
          alert("Cannot create overlapping event.");
        } else {
          const title = prompt("Enter event name:", "New Event") || "New Event";
          createEventElement(createDay, startSlot, endSlot, title);
        }
        isCreating = false;
        createDay = null;
        createStartSlot = null;
        createEndSlot = null;
      }
      if(isResizing && resizeEvent) {
        // Snap new end time
        const gridRect = calendarGrid.getBoundingClientRect();
        const cellHeight = gridRect.height / totalSlots;
        const currentHeight = resizeEvent.element.getBoundingClientRect().height + 4;
        let newEndSlot = Math.round(currentHeight / cellHeight) + resizeEvent.startSlot;
        newEndSlot = Math.max(resizeEvent.startSlot + 1, Math.min(newEndSlot, totalSlots));
        // Check overlap; if overlapping, revert
        if(hasOverlap(resizeEvent.day, resizeEvent.startSlot, newEndSlot, resizeEvent.id)) {
          alert("Resize would cause overlap. Reverting.");
          newEndSlot = originalEnd;
        }
        // Update the event in the global array
        events = events.map(ev => {
          if(ev.id == resizeEvent.id) {
            ev.end = newEndSlot;
          }
          return ev;
        });
        // Update the event element's label
        const titleElem = resizeEvent.element.querySelector(".event-title");
        if(titleElem){
          const currentTitle = titleElem.textContent.split("\n")[0];
          titleElem.innerHTML = currentTitle + "<br>" + slotToTime(resizeEvent.startSlot) + " - " + slotToTime(newEndSlot);
        }
        // Finally, adjust height
        resizeEvent.element.style.height = ((newEndSlot - resizeEvent.startSlot) * cellHeight - 4) + "px";
      }
      isResizing = false;
      resizeEvent = null;
    });
    
    // Current time line update
    function updateCurrentTimeLine() {
      const now = new Date();
      const currentMinutes = now.getHours() * 60 + now.getMinutes();
      const startMinutes = startHour * 60;
      const endMinutes = endHour * 60;
      if(currentMinutes < startMinutes || currentMinutes > endMinutes) {
        currentTimeLine.style.display = "none";
        return;
      }
      currentTimeLine.style.display = "block";
      const gridRect = calendarGrid.getBoundingClientRect();
      const totalMinutesDisplay = (endMinutes - startMinutes);
      const offsetY = ((currentMinutes - startMinutes) / totalMinutesDisplay) * gridRect.height;
      currentTimeLine.style.top = offsetY + "px";
    }
    updateCurrentTimeLine();
    setInterval(updateCurrentTimeLine, 60000);
    
    // Today button scroll to current time
    todayButton.addEventListener("click", function() {
      const gridRect = calendarGrid.getBoundingClientRect();
      const bodyRect = calendarBody.getBoundingClientRect();
      const now = new Date();
      const currentMinutes = now.getHours() * 60 + now.getMinutes();
      const startMinutes = startHour * 60;
      const endMinutes = endHour * 60;
      if(currentMinutes < startMinutes) {
        calendarBody.scrollTop = 0;
      } else if(currentMinutes > endMinutes) {
        calendarBody.scrollTop = calendarGrid.offsetHeight - calendarBody.clientHeight;
      } else {
        const totalMinutesDisplay = endMinutes - startMinutes;
        const scrollPos = ((currentMinutes - startMinutes) / totalMinutesDisplay) * calendarGrid.offsetHeight - bodyRect.height / 2;
        calendarBody.scrollTop = scrollPos;
      }
    });
    
    // Reposition events on window resize
    window.addEventListener("resize", function() {
      const gridRect = calendarGrid.getBoundingClientRect();
      const cellHeight = gridRect.height / totalSlots;
      const cellWidth = gridRect.width / daysCount;
      events.forEach(ev => {
        ev.element.style.left = (ev.day * cellWidth) + "px";
        ev.element.style.top = (ev.start * cellHeight) + "px";
        ev.element.style.width = (cellWidth - 4) + "px";
        ev.element.style.height = ((ev.end - ev.start) * cellHeight - 4) + "px";
      });
      updateCurrentTimeLine();
    });
    
    // Prevent overlapping drag events from creating selection when clicking on an event
    calendarGrid.addEventListener("click", function(e) {
      // if click on empty space, do nothing
    });
  </script>
</body>
</html>